# yield & send
## yield
`yield`用来制造生成器，包含`yield`的函数是生成器；<br>
`yield`语法规则:
- 在`yield`处暂停函数执行；
- 当`next`函数被调用时候，`next`函数返回值是`yield`后面表达式值(默认None)，并
从上次暂停处的`yield`处开始执行，直到遇到下一个`yield`；
- 当不能继续`next`时候，会抛出异常；

```python
>>> def yield_example(n):
...     a, b = 0, 1
...     for _ in range(n):
...         yield b
...         a, b = b, a + b
...
>>> gen = yield_example(5)
>>> gen  # 一个生成器
<generator object yield_example at 0x7f26336bd2e0>
>>> next(gen)
1
>>> next(gen)
1
>>> next(gen)
2
>>> next(gen)
3
>>> next(gen)
5
>>> next(gen)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
## send
生成器可以调用`send`方法，为内部的`yield`语句发送数据；此时的`yield`语句可以是`var = yield <expression>`形式，
该形式具有如下两个功能:
- 暂停函数执行；
- 接收外部`send`方法发送的值，重新激活函数，并将发送的值赋值给 var 变量；

```python
>>> def simple_coroutine():
...     print("Start coroutine ---")
...     y = 10
...     x = yield y
...     print("Coroutine get x value: ", x)
...
>>> my_coro = simple_coroutine()
>>> my_coro
<generator object simple_coroutine at 0x7f7c66b08a50>
>>> ret = next(my_coro)
Start coroutine ---
>>> print(ret)
10
>>> my_coro.send(100)
Coroutine get x value:  100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
协程有四个状态，当前状态可以使用`inspect.getgeneratorstate`函数查看
- 'GEN_CREATED': 等待开始执行；
- `GEN_RUNNING`: 正在执行；
- `GEN_SUSPENDED`: 在`yield`处暂停；
- `GEN_CLOSED`: 执行结束;

```python
>>> def simple_coroutine():
...     print("Start coroutine ---")
...     y = 10
...     x = yield y
...     print("Coroutine get x value: ", x)
...
>>> my_coro = simple_coroutine()
>>> import inspect
>>> inspect.getgeneratorstate(my_coro)
'GEN_CREATED'
>>> next(my_coro)
Start coroutine ---
10
>>> inspect.getgeneratorstate(my_coro)
'GEN_SUSPENDED'
>>> my_coro.send(100)
Coroutine get x value:  100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> inspect.getgeneratorstate(my_coro)
'GEN_CLOSED'
```
`send`函数方法参数会成为暂停`yield`表达式的值，只有当协程处于暂停状态才可以调用`send`函数；
如果协程还未被激活(状态是`GEN_CREATED`)，把`None`之外的值发给它，会抛出异常。
```python
>>> def simple_coroutine():
...     print("Start coroutine ---")
...     y = 10
...     x = yield y
...     print("Coroutine get x value: ", x)
...
>>> inspect.getgeneratorstate(my_coro)
'GEN_CLOSED'
>>> my_coro = simple_coroutine()
>>> inspect.getgeneratorstate(my_coro)
'GEN_CREATED'
>>> my_coro.send(10)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't send non-None value to a just-started generator
```
使用协程之前需要先激活协程，使用`next(my_coro)`或者`my_coro.send(None)`。
