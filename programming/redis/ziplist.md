> 基于`redis`源码分支`5.0`
# 压缩列表
压缩列表`ziplist`是列表键和哈希键的底层实现之一。当一个列表键包含少量的列表项，且每个列表项是小整数或者长度比较短的字符串，
`redis`使用压缩列表作为列表键的底层实现。或者当一个哈希键包含少量的键值对，且每个键值对的键和值要么是小整数值或长度比较短的字符串，
`redis`使用压缩列表作为哈希键的底层实现。

压缩列表`ziplist`是`redis`为了节约内存开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。
一个压缩列表可以包含任意个节点`entry`，每个节点保存一个字节数组（字符串），或一个整数。

节约内存体现如下：
+ 压缩列表使用连续的存储空间，避免内存碎片；
+ 和数组相比，数据每个元素大小是根据最大元素类型定义的，对于小元素类型存在浪费。但压缩列表中的每一`entry`大小是根据实际存储值决定，
也就是没有浪费，`entry`大小可能都不一样；
+ 和链表相比，压缩列表由于存储小整数和短字符串，节约了链表上指针开销（一个指针占用字节蛮多的，`64`位操作系统是`8`字节）；

## 数据结构定义
`redis`使用字节数组表示压缩列表`ziplist`，`ziplist`的结构如下：
```bash
+-------+------+-----+-----+-----+-----+-----+-----+
|zlbytes|zltail|zllen|entry|entry| ... |entry|zlend|
+-------+------+-----+-----+-----+-----+-----+-----+
```
+ `zlbytes`：`4`个字节（`uint32_t`类型），记录整个压缩列表占用的内存字节数。用于压缩列表进行内存重分配或者计算特殊值`zlend`位置。
+ `zltail`：`4`个字节（`uint32_t`类型），记录压缩列表最后一个`entry`到压缩列表起始地址有多少字节，
通过这个偏移量，不需要遍历完整的压缩列表就可以知道压缩列表最后`entry`的地址。
+ `zllen`：`2`个字节（`uint16_t`类型），记录压缩列表节点数量，当实际压缩列表节点数量超过`2^16-1`时，
需要遍历整个`entry`项才可以获取实际节点数量。
+ `entry`：压缩列表中保存的节点，节点的长度由节点保存的内存决定。
+ `zlend`：`1`个字节（`uint8_t`类型），特殊值`0xFF`，表示压缩列表的结束。

节点`entry`的结构如下：
```bash
+-------+--------+----------+
|prevlen|encoding|entry-data|
+-------+--------+----------+
```
+ `prevlen`：记录压缩列表前一个节点的长度，以字节为单位。
  + 如果前一个节点长度小于`254`个字节，则`prevlen`的值用`1`个字节表示；
  + 如果前一个节点长度大于等于`254`个字节，则`prevlen`的值用`5`个字节表示，且第一个字节设置为`0xFE`，
  接下来的`4`个字节表示前一个节点的长度；
+ `encoding`：
+ `entry-data`：
