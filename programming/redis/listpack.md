> 基于`redis`源码分支`5.0`

# listpack
`listpack`数据结构和之前介绍的[ziplist数据结构](./ziplist.md)很像，其实`listpack`是作为`ziplist`的替代，
主要解决`ziplist`中的连锁更新问题，因为`listpack`不记录上一个元素节点的大小信息，所以不会存在连锁更新问题。

## listpack数据结构
`listpack`（`A lists of strings serialization format`）是一个序列化格式的字符串列表，数据结构如下：
```bash
+------------+----------+--------+-----+--------+-----+
| total bytes| num elem | entry1 | ... | entryN | end |
+------------+----------+--------+-----+--------+-----+
```
+ `total bytes`：整个`listpack`对象的空间大小，`4`个字节；
+ `num elem`：`listpack`对象包含的元素个数，也就是`entry`的个数，`2`个字节，如果`num elem`值是`65535`，
说明实际元素的个数可能比`65535`大，为了获取实际的元素个数，需要遍历整个`listpack`；
+ `end`：`listpack`对象结束标志，`1`个字节，值为`0xFF`；
+ `entryx`：实际存储的元素。`enrty`可以存储字符串或者整数，`entry`的由三部分组成：
  ```bash
  +--------+---------+---------+
  | encode | content | backlen |
  +--------+---------+---------+
  ``` 
  + `encode`：编码类型，决定后面`content`存储的内容，`1`个字节，`encode`值和含义说明如下：
    + 取值`0xxx xxxx`：`7`位长度的无符号整数，范围`0-127`，后`7`位为数据；
    + 取值`110x xxxx`：`13`位长度表示的有符号整数，范围`-4096-4095`，后`5`位及接下来一个字节表示数据；
    + 取值`1111 0001`：表示`16`位有符号整数，范围`-32768-32767`，接下来`2`个字节表示数据；
    + 取值`1111 0010`：表示`24`位有符号整数，范围`-8388608-8388607`，接下来`3`个字节表示数据；
    + 取值`1111 0011`：表示`32`位有符号整数，范围`-2147483648-2147483647`，接下来`4`个字节表示数据；
    + 取值`1111 0100`：表示`64`位有符号整数，接下来`8`个字节表示数据；
    + 取值`10xx xxxx`：`6`位长度表示的无符号整数字符串长度，后`6`位表示字符串长度，接下来是字符串数据；
    + 取值`1110 xxxx`：`12`位长度表示的无符号整数字符串长度，后`4`位是高位，接下里`1`个字节是低位，在之后才是字符串数据；
    + 取值`1111 0000`：`32`位长度表示的无符号整数字符串长度，接下来`4`个字节表示字符串长度，之后才是字符串数据；
    
    对于负整数，`redis`将其转为正整数存储，例如对于`13`位整数存储中，存储范围`[0, 8191]`，
    其中`[0, 4095]`表示`0-4095`，`[4096, 8191]`表示`-4096 - -1`。
  + `content`：实际存储的数据，字符串或者整数；
  + `backlen`：值表示当前`entry`的`encode`加`content`的长度，单位字节，占用字节数小于等于`5`；
  `backlen`的每个字节的第一位是标志位，`0`表示结束，`1`表示未结束，剩下的七位为有效位。
  `backlen`用于`listpack`对象从后往前遍历。`backlen`的编码和解码规则如下：
    ```bash
            +-+-+-+-+-+-+-+-+
    1个字节 |0|x|x|x|x|x|x|x|
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    2个字节 |0|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    3个字节 |0|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    4个字节 |0|x|x|x|X|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    5个字节 |0|x|x|x|X|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|1|x|x|x|x|x|x|x|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ```
    编码规则：从左往右。解码规则：从右往左。例如数字`136`的二进制是`0000001 0001000`，需要`2`个字节存储（每个字节只有七位是有效的），
    编码流程如下：
    + 右移`7`位，保留高`7`位，也就是`0000001`，保存在`p[0]`位置，`p[0]`的第一位为`0`；
    + 将剩下的低`7`位，也就是`00010001`，保存在`p[1]`位置，`p[1]`的第一位为`1`；
    此时`backlen`的二进制值是`00000001 10001000`；

    解码的流程如下：
    + 解码`p[1]`的值`10001000`取低`7`位`0001000`，也就是十进制`8`，保存为`v=8`；
    取最高位值看是否为`1`，如果为`1`继续取下一个字节；
    + 解码`p[0]`的值`00000001`，取低`7`位`0000001`，因为是解码的第二个字节，将其左移`7`位，
    即`0000001 << 7 = 128`，将其和上一步的`v`相加，即`v = 8 + 128 = 136`；取最高位为`0`，解码结束，
    得到`backlen=136`；
