基于`TCP`的`Socket`编程流程如下：
![socket编程流程](./images/socket编程流程.png)

# Socket API 功能
## bind
**作用**：将 IP 地址/端口信息绑定在`socket`相关数据结构上，并且根据通过端口映射，将`socket`指针保存在内核哈希表里。

工作原理：
+ 确保套接字参数`socketfd`（一个整数）小于`NR_OPEN`配置。
  > `NR_OPEN`表示系统支持的最大文件描述符数量（Ubuntu 测试值为 1048576），此值在编译时确定，在运行时不可更改，如果更改需要重新编译内核。
  使用命令`sysctl fs.nr_open`或`cat /proc/sys/fs/nr_open`查看。
+ 内核通过拉链哈希表的方式来管理所有的`bind`的`socket`。哈希表是由数组和链表组成的，哈希槽上保存的是哈希冲突的（多个）`bucket`，
它们用链表串联一起，遍历链表找出对应端口所在的`bucket`，下面的`tbx`就是一个`bucket`。哈希表结构如下：
  ```bash
    bhash
  +------+
  |  ... |
  +------+      +------+      +------+      +------+
  | head | <==> | tb1  | <==> | tb2  | <==> | ...  |
  +------+      +------+      +------+      +------+
  |  ... |
  +------+
  ```
  端口值是计算哈希值的一个参数，当计算找到哈希槽位以后，遍历所有的`bind`状态的`socket`，目的是为了判断是否冲突。
  + 如果在哈希表里**找到**了对应的`bucket`满足其网络命名空间和端口号与正在进行绑定的`socket`一样，
  说明正在绑定的端口已经被绑定过了。查看已经绑定的`socket`和正在绑定的`socket`是否都开启了`SO_REUSEADDR`且正在绑定的`socket`不是`listen`状态，
  或者查看已经绑定的`socket`和正在绑定的`socket`是否都开启了`SO_REUSEPORT`且在相同的用户空间下，
  如果上述条件为真则走绑定成功逻辑，将正在绑定的`socket`作为一个`bucket`添加到哈希表中，
  否则返回绑定失败，也就是看到端口已被占用错误。
  + 如果**没有找到**`bucket`满足其网络命名空间和端口号与正在进行绑定的`socket`一样，说明正在绑定的端口之前没有被绑定过，
  直接走绑定成功逻辑，将正在绑定的`socket`作为一个`bucket`添加到哈希表中。

IP 地址的绑定在端口绑定之前就已经完成。

## listen

## connect

## accept
**作用**：从已经建立好的**全连接队列中**取出第一个返回给用户进程。

工作原理：
+ 内核仍然是通过`hash` + 拉链的方式来保存所有的`listen`状态的`socket`。如下所示：
  ```bash
    listening_hash
  +----------------+
  |       ...      |
  +----------------+      +---------+      +----------+      +------+
  |      head      | <==> | socket1 | <==> |  socket2 | <==> | ...  |
  +----------------+      +---------+      +----------+      +------+
  |       ...      |
  +----------------+
  ```
  当有多个进程都`bind`和`listen`了同一个端口的时候。有客户端连接请求到来的时候就涉及到选择哪个`socket`（进程）进行处理的问题。
+ 在`accept`内部，会对`hash`值相同的所有`listen`状态的`socket`计算匹配分，匹配分最高的`socket`会被选中。基于匹配分规则样例说明如下：
  + 假设一台机器有
